{
  // ref: https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm
  parserClass='org.ice1000.julia.lang.JuliaParser'
  extends='com.intellij.extapi.psi.ASTWrapperPsiElement'
  psiClassPrefix='Julia'
  psiImplClassSuffix='Impl'
  psiPackage='org.ice1000.julia.lang.psi'
  psiImplPackage='org.ice1000.julia.lang.psi.impl'

  extends('.*Op|.*Expr|.*Lit|.*ymbol')=expr

  tokenTypeClass='org.ice1000.julia.lang.JuliaTokenType'
  elementTypeHolderClass='org.ice1000.julia.lang.psi.JuliaTypes'
  elementTypeClass='org.ice1000.julia.lang.JuliaElementType'
  psiImplUtilClass='org.ice1000.julia.lang.psi.impl.JuliaPsiImplUtils'
}

juliaFile ::= endOfLine statements

symbol ::= SYM
macroSymbol ::= AT_SYM SYM
identifier ::= identifierImpl { extends=expr }
private identifierChain ::= endOfLine DOT_SYM endOfLine symbol
private anySym ::= symbol | macroSymbol
private identifierImpl ::= (anySym identifierChain*) | (anySym? identifierChain+)

unaryOpAsSymbol ::=
   INTERPOLATE_SYM
 | MINUS_SYM
 | DOT_SYM
 | PLUS_SYM
 | NOT_SYM

nonUnaryOpAsSymbol ::=
   SEMICOLON_SYM
 | COMMA_SYM
 | QUESTION_SYM
 | SUBTYPE_SYM
 | INTERPOLATE_SYM
 | INVERSE_DIV_SYM
 | IS_SYM
 | ISNT_SYM
 | LAMBDA_ABSTRACTION
 | ARROW_SYM
 | SLICE_SYM
 | LESS_THAN_SYM
 | LESS_THAN_OR_EQUAL_SYM
 | AND_SYM
 | OR_SYM
 | PIPE_SYM
 | INVRESE_PIPE_SYM
 | SHL_SYM
 | SHR_SYM
 | USHR_SYM
 | FRACTION_SYM
 | DIVIDE_SYM
 | REMAINDER_SYM
 | EXPONENT_SYM
 | MULTIPLY_SYM
 | EQUALS_SYM
 | UNEQUAL_SYM
 | GREATER_THAN_SYM
 | GREATER_THAN_OR_EQUAL_SYM
 | TRANSPOSE_SYM
 | IN_SYM
 | MISC_COMPARISON_SYM
 | MISC_PLUS_SYM
 | MISC_MULTIPLY_SYM
 | MISC_EXPONENT_SYM
 | FACTORISE_SYM
 | BITWISE_AND_SYM
 | BITWISE_OR_SYM
 | BITWISE_XOR_SYM
 | SPECIAL_ARROW_SYM
 | MISC_ARROW_SYM
 | BITWISE_NOT_SYM
 | EQ_SYM
 | ASSIGN_SYM
 | COLON_ASSIGN_SYM
 | BITWISE_AND_ASSIGN_SYM
 | BITWISE_OR_ASSIGN_SYM
 | BITWISE_XOR_ASSIGN_SYM
 | INVERSE_DIV_ASSIGN_SYM
 | SHL_ASSIGN_SYM
 | SHR_ASSIGN_SYM
 | REMAINDER_ASSIGN_SYM
 | USHR_ASSIGN_SYM
 | PLUS_ASSIGN_SYM
 | MINUS_ASSIGN_SYM
 | MULTIPLY_ASSIGN_SYM
 | FRACTION_ASSIGN_SYM
 | DIVIDE_ASSIGN_SYM
 | FACTORISE_ASSIGN_SYM
 | EXPONENT_ASSIGN_SYM

private comment ::= blockComment | LINE_COMMENT
private blockComment ::= BLOCK_COMMENT_START (BLOCK_COMMENT_BODY | blockComment) BLOCK_COMMENT_END

string ::= cmd | str | rawStr { extends=expr }
private cmd ::= CMD_QUOTE_START stringTemplateElement* CMD_QUOTE_END
private str ::= QUOTE_START stringTemplateElement* QUOTE_END
private rawStr ::= TRIPLE_QUOTE_START stringTemplateElement* TRIPLE_QUOTE_END

stringTemplateElement::=
   STRING_UNICODE
 | STRING_ESCAPE
 | template
 | REGULAR_STRING_PART_LITERAL { pin=1 }

private template ::= SHORT_INTERPOLATE_SYM symbol | STRING_INTERPOLATE_START expr STRING_INTERPOLATE_END

integer ::= INT_LITERAL { extends=expr }
floatLit ::= FLOAT_LITERAL | FLOAT_CONSTANT
booleanLit ::= TRUE_KEYWORD | FALSE_KEYWORD
charLit ::= CHAR_LITERAL

private endOfLineImpl ::= EOL | comment
private endOfLine ::= endOfLineImpl*
private semi ::= endOfLineImpl | SEMICOLON_SYM
statements ::= semi* (statement (semi+ statement)*)? semi*

private statement ::=
   moduleDeclaration
 | expr

moduleType ::= BAREMODULE_KEYWORD | MODULE_KEYWORD
moduleName ::= identifierImpl
moduleDeclaration ::=
 moduleType moduleName endOfLine
  statements
 END_KEYWORD

assignment ::=
 typedVariable endOfLine
 (
  EQ_SYM endOfLine
  expr
 )?

typeAnnotation ::= DOUBLE_COLON endOfLine identifier
typedVariable ::=
 (LOCAL_KEYWORD endOfLine)?
 identifier endOfLine
  (typeAnnotation endOfLine)?
 typeParameters?

typeParameters ::=
 LEFT_B_BRACKET endOfLine
  expr (endOfLine COMMA_SYM endOfLine expr?)* endOfLine
 RIGHT_B_BRACKET

userType ::= identifier typeParameters?
typeModifiers ::= (IMMUTABLE_KEYWORD | MUTABLE_KEYWORD)?
typeAlias ::= TYPEALIAS_KEYWORD typeName typeParameters? userType { extends=expr }

private expressionList ::= expr (endOfLine COMMA_SYM endOfLine expr)* COMMA_SYM?

expr ::=
   assigns
 | arrowOp
 | ternaryOp
 | applyIndexOp
 | applyFunctionOp
 | miscArrowsOp
 | orOp
 | andOp
 | lambda
 | level6
 | invPipeOp
 | pipeOp
 | level8
 | level9
 | level10
 | level11
 | fractionOp
 | level13
 | typeOp
 | level14
 | level15
 | primaryExpr
 | bracketedExpr

private assigns ::=
   assignOp
 | remainderAssignOp
 | plusAssignOp
 | minusAssignOp
 | multiplyAssignOp
 | fractionAssignOp
 | divideAssignOp
 | factoriseAssignOp
 | exponentAssignOp
 | ushrAssignOp
 | shlAssignOp
 | shrAssignOp
 | colonAssignOp
 | inverseDivAssignOp
 | bitwiseAndAssignOp
 | bitwiseOrAssignOp
 | bitwiseXorAssignOp
 | bitWiseNotOp

bitWiseNotOp ::= BITWISE_NOT_SYM endOfLine expr
colonAssignOp ::= expr COLON_ASSIGN_SYM endOfLine expr { rightAssociative=true }
bitwiseAndAssignOp ::= expr BITWISE_AND_ASSIGN_SYM endOfLine expr { rightAssociative=true }
bitwiseOrAssignOp ::= expr BITWISE_OR_ASSIGN_SYM endOfLine expr { rightAssociative=true }
bitwiseXorAssignOp ::= expr BITWISE_XOR_ASSIGN_SYM endOfLine expr { rightAssociative=true }
inverseDivAssignOp ::= expr INVERSE_DIV_ASSIGN_SYM endOfLine expr { rightAssociative=true }
shlAssignOp ::= expr SHL_ASSIGN_SYM endOfLine expr { rightAssociative=true }
shrAssignOp ::= expr SHR_ASSIGN_SYM endOfLine expr { rightAssociative=true }
remainderAssignOp ::= expr REMAINDER_ASSIGN_SYM endOfLine expr { rightAssociative=true }
ushrAssignOp ::= expr USHR_ASSIGN_SYM endOfLine expr { rightAssociative=true }
plusAssignOp ::= expr PLUS_ASSIGN_SYM endOfLine expr { rightAssociative=true }
minusAssignOp ::= expr MINUS_ASSIGN_SYM endOfLine expr { rightAssociative=true }
multiplyAssignOp ::= expr MULTIPLY_ASSIGN_SYM endOfLine expr { rightAssociative=true }
fractionAssignOp ::= expr FRACTION_ASSIGN_SYM endOfLine expr { rightAssociative=true }
divideAssignOp ::= expr DIVIDE_ASSIGN_SYM endOfLine expr { rightAssociative=true }
factoriseAssignOp ::= expr FACTORISE_ASSIGN_SYM endOfLine expr { rightAssociative=true }
exponentAssignOp ::= expr EXPONENT_ASSIGN_SYM endOfLine expr { rightAssociative=true }
assignOp ::= expr (EQ_SYM | ASSIGN_SYM) endOfLine expr { rightAssociative=true }

// level 1.5
arrowOp ::= expr ARROW_SYM endOfLine expr { rightAssociative=true }

// ? :
// level 2
ternaryOp ::= expr QUESTION_SYM endOfLine expr COLON_SYM endOfLine expr

// level 2.25
applyIndexOp ::= expr LEFT_M_BRACKET expr? endOfLine RIGHT_M_BRACKET { rightAssociative=true }

// level 2.375
applyFunctionOp ::=
 expr LEFT_BRACKET endOfLine
  expressionList? endOfLine
 RIGHT_BRACKET { rightAssociative=true }

// All reserved but unassigned
// level 2.5
miscArrowsOp ::= expr (SPECIAL_ARROW_SYM | MISC_ARROW_SYM) endOfLine expr

// ||
// level 3
orOp ::= expr OR_SYM endOfLine expr

// &&
// level 4
andOp ::= expr AND_SYM endOfLine expr

// ->
// level 5
lambda ::= symbol LAMBDA_ABSTRACTION endOfLine expr {
	rightAssociative=true
	extends=expr
}

private level6 ::=
   lessThanOrEqualOp
 | lessThanOp
 | greaterThanOp
 | greaterThanOrEqualOp
 | isntOp
 | isOp
 | equalsOp
 | unequalOp
 | subtypeOp
 | miscComparisonOp

lessThanOp ::= expr LESS_THAN_SYM endOfLine expr
lessThanOrEqualOp ::= expr LESS_THAN_OR_EQUAL_SYM endOfLine expr
greaterThanOp ::= expr GREATER_THAN_SYM endOfLine expr
greaterThanOrEqualOp ::= expr GREATER_THAN_OR_EQUAL_SYM endOfLine expr
equalsOp ::= expr EQUALS_SYM endOfLine expr
unequalOp ::= expr UNEQUAL_SYM endOfLine expr
isOp ::= expr IS_SYM endOfLine expr
isntOp ::= expr ISNT_SYM endOfLine expr
subtypeOp ::= expr SUBTYPE_SYM endOfLine expr
miscComparisonOp ::= expr MISC_COMPARISON_SYM endOfLine expr

// |>
// level 7
pipeOp ::= expr PIPE_SYM endOfLine expr
invPipeOp ::= expr INVERSE_PIPE_SYM endOfLine expr

private level8 ::=
   spliceOp
 | quoteOp
 | compoundQuoteOp

spliceOp ::= expr SLICE_SYM
// TODO review if this should be a quoted expression!!! with interpolation
quoteOp ::= COLON_SYM endOfLine expr
compoundQuoteOp ::= QUOTE_KEYWORD endOfLine (expr endOfLine)* END_KEYWORD

// + - etc
private level9 ::=
   plusOp
 | minusOp
 | bitwiseXorOp
 | bitwiseOrOp
 | miscPlusOp

bitwiseXorOp ::= expr (INTERPOLATE_SYM | BITWISE_XOR_SYM) endOfLine expr
bitwiseOrOp ::= expr BITWISE_OR_SYM endOfLine expr
plusOp ::= expr PLUS_SYM endOfLine expr
minusOp ::= expr MINUS_SYM endOfLine expr
miscPlusOp ::= expr MISC_PLUS_SYM endOfLine expr

private level10 ::=
   shlOp
 | shrOp
 | ushrOp
 | transposeOp
 | rangeOp

shrOp ::= expr SHR_SYM endOfLine expr
ushrOp ::= expr USHR_SYM endOfLine expr
shlOp ::= expr SHL_SYM endOfLine expr
transposeOp ::= expr TRANSPOSE_SYM
rangeOp ::= expr COLON_SYM endOfLine expr

// * / % & ^
private level11 ::=
   multiplyOp
 | divideOp
 | remainderOp
 | bitwiseAndOp
 | inverseDivideOp
 | factoriseOp
 | miscMultiplyOp
 | specialMultiplyOp

multiplyOp ::= expr MULTIPLY_SYM endOfLine expr
divideOp ::= expr DIVIDE_SYM endOfLine expr
remainderOp ::= expr REMAINDER_SYM endOfLine expr
inverseDivideOp ::= expr INVERSE_DIV_SYM endOfLine expr
factoriseOp ::= expr FACTORISE_SYM endOfLine expr
bitwiseAndOp ::= expr BITWISE_AND_SYM endOfLine expr
miscMultiplyOp ::= expr MISC_MULTIPLY_SYM endOfLine expr

// // .//
// level 12
fractionOp ::= expr FRACTION_SYM endOfLine expr

// ^ .^
private level13 ::=
   miscExponentOp
 | exponentOp

exponentOp ::= expr EXPONENT_SYM endOfLine expr
miscExponentOp ::= expr MISC_EXPONENT_SYM endOfLine expr

// ::
// level 13.5
typeOp ::= expr DOUBLE_COLON endOfLine expr

private level14 ::= unaryOpAsSymbol

// TODO not sure if it covers all unary symbols
private level15 ::=
   unaryPlusOp
 | unaryMinusOp
 | notOp
 | interpolateOp

unaryMinusOp ::= MINUS_SYM endOfLine expr
notOp ::= NOT_SYM endOfLine expr
unaryPlusOp ::= PLUS_SYM endOfLine expr
interpolateOp ::= INTERPOLATE_SYM endOfLine expr

private primaryExpr ::=
   string
 | charLit
 | integer
 | floatLit
 | booleanLit
 | lhs
 | nonUnaryOpAsSymbol
 | ifExpr
 | forExpr
 | whileExpr
 | function
 | compactFunction
 | returnExpr
 | breakExpr
 | tryCatch
 | continueExpr
 | array
 | union
 | macro
 | let
 | block
 | export
 | importExpr
 | using
 | abstractTypeDeclaration
 | primitiveTypeDeclaration
 | typeDeclaration
 | typeReference
 | typeAlias

lhs ::= ((LOCAL_KEYWORD | CONST_KEYWORD) endOfLine)? identifierImpl { extends=expr }

bracketedExpr ::= LEFT_BRACKET endOfLine expr endOfLine RIGHT_BRACKET { extends=expr }

array ::= LEFT_M_BRACKET endOfLine expressionList? RIGHT_M_BRACKET { extends=expr }

union ::= UNION_KEYWORD tuple { extends=expr }

tuple ::=
 LEFT_BRACKET endOfLine
  expr (endOfLine COMMA_SYM endOfLine expr)+ endOfLine COMMA_SYM? endOfLine
 RIGHT_BRACKET { extends=expr }

private variables ::=
 LEFT_BRACKET endOfLine
  (typedVariable (endOfLine COMMA_SYM endOfLine typedVariable)*)? endOfLine
 RIGHT_BRACKET

private untypedVariables ::=
 LEFT_BRACKET endOfLine
  (symbol (endOfLine COMMA_SYM endOfLine symbol)*)? endOfLine
 RIGHT_BRACKET

functionName ::= SYM
function ::=
 FUNCTION_KEYWORD endOfLine
    functionName endOfLine
     (typeParameters endOfLine)?
   variables typeAnnotation? endOfLine
  statements
 END_KEYWORD { extends=expr }

compactFunction ::=
 functionName endOfLine
  (typeParameters endOfLine)?
   variables EQ_SYM endOfLine
 expr { extends=expr }

typeName ::= identifierImpl
abstractTypeName ::= identifierImpl
primitiveTypeName ::= identifierImpl
typeReference ::= identifier typeParameters? { extends=expr }
typeDeclaration ::=
 typeModifiers (TYPE_KEYWORD | STRUCT_KEYWORD) endOfLine
  typeName (SUBTYPE_SYM endOfLine identifier)? endOfLine
  (
   ( assignment
   | function
   | compactFunction
   | identifier
   )
   endOfLine
  )*
 END_KEYWORD { extends=expr }

abstractTypeDeclaration ::=
 ABSTRACT_KEYWORD TYPE_KEYWORD endOfLine
  abstractTypeName (SUBTYPE_SYM endOfLine identifier)? endOfLine
 END_KEYWORD { extends=expr }

primitiveTypeDeclaration ::=
 PRIMITIVE_KEYWORD TYPE_KEYWORD endOfLine
  primitiveTypeName (SUBTYPE_SYM endOfLine identifier)? expr endOfLine
 END_KEYWORD { extends=expr }

macroName ::= SYM
macro ::=
 MACRO_KEYWORD endOfLine
    macroName endOfLine
   untypedVariables endOfLine
  statements
 END_KEYWORD { extends=expr }

let ::= LET_KEYWORD blockInternal { extends=expr }

block ::= BEGIN_KEYWORD blockInternal { extends=expr }

private blockInternal ::= statements END_KEYWORD

breakExpr ::= BREAK_KEYWORD

continueExpr ::= CONTINUE_KEYWORD

export ::=
 EXPORT_KEYWORD endOfLine
  identifier
  (endOfLine COMMA_SYM endOfLine
   identifier)* { extends=expr }

importExpr ::=
 IMPORT_KEYWORD endOfLine
  identifier endOfLine
  (COLON_SYM endOfLine
   identifier
   (
    endOfLine
    COMMA_SYM endOfLine
    identifier
   )*
  )?

using ::=
 USING_KEYWORD endOfLine
  identifier? (endOfLine COMMA_SYM endOfLine identifier)* { extends=expr }

// The block comment inside is a kind of strange behavior of the Julia compiler.
// Not mentioned in the reference, but it's how the compiler works.
specialMultiplyOp ::= simpleSymbol BLOCK_COMMENT? simpleSymbol
private simpleSymbol ::=
   integer
 | floatLit
 | string
 | symbol

ifExpr ::=
 IF_KEYWORD statements
  elseIfClause*
  elseClause?
 END_KEYWORD { extends=expr }

elseIfClause ::= ELSEIF_KEYWORD statements
elseClause ::= ELSE_KEYWORD statements

forExpr ::= indexer statements END_KEYWORD { extends=expr }
private indexer ::= FOR_KEYWORD endOfLine (multiIndexer | singleIndexer)
private infixIndexer ::= IN_KEYWORD | IN_SYM | EQ_SYM
singleIndexer ::= symbol infixIndexer endOfLine expr
multiIndexer ::=
 LEFT_BRACKET endOfLine
  symbol (endOfLine COMMA_SYM endOfLine symbol)+ endOfLine
 RIGHT_BRACKET
 infixIndexer endOfLine
 expr

whileExpr ::=
 WHILE_KEYWORD endOfLine
  expr endOfLine
   statements
 END_KEYWORD { extends=expr }

returnExpr ::= RETURN_KEYWORD expr?
tryCatch ::=
 TRY_KEYWORD endOfLine
  statements
 catchClause?
 finallyClause?
 END_KEYWORD { extends=expr }

catchClause ::=
 CATCH_KEYWORD symbol? endOfLine
 statements

finallyClause ::=
 FINALLY_KEYWORD statements
